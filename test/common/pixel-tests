#!/bin/bash

GITHUB_REPO='pixel-test-reference'
SUBDIR='test/reference'

set -eu
cd "$(realpath -m "$0"/../../..)"
. pkg/lib/git-utils.sh

cmd_init() {
    git submodule add -b empty "$CLONE_REMOTE" "$SUBDIR"
}

cmd_checkout() {
    local sha="${1-$(get_index_gitlink node_modules)}"

    fetch_sha_to_cache "${sha}"
    cmd_remove
    clone_from_cache "${sha}"
}

cmd_pull() {
    # Our main goal is to ensure that the test/reference from
    # the index is the one that we actually have.
    local sha="$(get_index_gitlink test/reference)"
    if [ ! -e test/reference/.git ]; then
        # nothing there yet...
        cmd_checkout "${sha}"
    elif [ "$(git -C test/reference rev-parse HEAD)" != "${sha}" ]; then
        # wrong thing there...
        cmd_checkout "${sha}"
    fi
}

cmd_status() {
    ( cd "$SUBDIR"
      git rm --force --cached --quiet '*.png'
      git add *.png
      if git diff-index --name-status --cached --exit-code HEAD; then
          echo No changes
      fi
    )
}

cmd_push() {
    ( cd "$SUBDIR"
      git rm --force --cached --quiet '*.png'
      git add *.png
      if ! git diff-index --name-status --cached --exit-code HEAD; then
          git fetch origin empty:empty
          git reset --soft empty
          git commit --quiet -m "$(date)"
      else
          echo No changes
      fi
      tag="sha-$(git rev-parse HEAD)"
      [ $(git tag -l "$tag") ] || git tag "$tag" HEAD
      git push "$SSH_REMOTE" "$tag"
    )
    git add "$SUBDIR"
}

main() {
    local cmd="${1-}"

    if [ -z "${cmd}" ]; then
        echo 'This command requires a subcommand: init pull status push'
        exit 1
    elif ! type -t "cmd_${cmd}" | grep -q function; then
        echo "Unknown subcommand ${cmd}"
        exit 1
    fi

    shift
    [ -n "${quiet}" ] || set -x
    "cmd_$cmd" "$@"
}

main "$@"
